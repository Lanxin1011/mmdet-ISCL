import numpy as np
import cv2
import tqdm
import xml.etree.ElementTree as ET
from pycocotools.coco import COCO
import pycocotools.mask as maskUtils
from collections import defaultdict

import mmcv
import aitool


class PklParserBase():
    """parse the pkl file (generated by mmdetection)
    """
    def __init__(self,
                 pkl_file,
                 ann_file,
                 keep_boundary=True,
                 score_threshold=0.05,
                 min_area=10):
        self.keep_boundary = keep_boundary
        self.score_threshold = score_threshold
        self.min_area = min_area

        if isinstance(pkl_file, str):
            results = mmcv.load(pkl_file)
        elif isinstance(pkl_file, (list, tuple)):
            results = pkl_file
        else:
            raise TypeError(f'do not support the pkl file type: {type(pkl_file)}')

        coco = COCO(ann_file)
        self.img_ids = coco.get_img_ids()
        self.cat_ids = coco.get_cat_ids()
        self.img_fns = []
        self.img_sizes = []

        print("begin to convert pkl file to specific format")
        self.objects = dict()
        self.objects_with_id = dict()
        for idx, img_id in tqdm.tqdm(enumerate(self.img_ids)):
            info = coco.load_imgs([img_id])[0]
            img_name = aitool.get_basename(info['file_name'])
            img_size = (info['height'], info['width'])
            self.img_fns.append(img_name)
            result = results[idx]

            self.objects[img_name] = self._convert_items(result, img_size=img_size)
            self.objects_with_id[img_id] = self.objects[img_name].copy()

    def _convert_items(self, result, img_size=(1024, 1024)):
        """convert the result (single image) in pkl file to specific format (default: Faster R-CNN, bbox) 

        Args:
            result (tuple): detection result of single image
            img_size (tuple): image size (height, width)

        Return:
            list: converted objects
        """
        objects = []

        for label in range(len(result)):
            bboxes = result[label]
            for i in range(bboxes.shape[0]):
                data = dict()
                data['bbox'] = aitool.xyxy2xywh(bboxes[i][:4])
                if data['bbox'][2] * data['bbox'][3] < self.min_area:
                    continue
                data['score'] = float(bboxes[i][4])
                if data['score'] < self.score_threshold:
                    continue
                data['category_id'] = self.cat_ids[label]
                objects.append(data)

        return objects

    def __call__(self, image_fn):
        if image_fn in self.objects.keys():
            return self.objects[image_fn]
        else:
            print("{} is not in pkl".format(image_fn))
            return []


class PklParserMask(PklParserBase):
    def _convert_items(self, result, img_size=(1024, 1024)):
        """convert the result (single image) in pkl file to specific format (Mask R-CNN, bbox + mask) 

        Args:
            result (tuple): detection result of single image
            img_size (tuple): image size (height, width)

        Return:
            list: converted objects
        """
        objects = []

        det, seg = result
        for label in range(len(det)):
            bboxes = det[label]
            if isinstance(seg, tuple):
                segms = seg[0][label]
            else:
                segms = seg[label]

            for i in range(bboxes.shape[0]):
                data = dict()
                data['bbox'] = aitool.xyxy2xywh(bboxes[i][:4])
                if data['bbox'][2] * data['bbox'][3] < self.min_area:
                    continue
                data['score'] = float(bboxes[i][4])
                if data['score'] < self.score_threshold:
                    continue
                data['category_id'] = self.cat_ids[label]
                if isinstance(segms[i]['counts'], bytes):
                    segms[i]['counts'] = segms[i]['counts'].decode()
                data['segmentation'] = segms[i]
                data['pointobb'] = aitool.bbox2pointobb(bboxes[i][:4])
                objects.append(data)

        return objects


class PklParserMaskOBB(PklParserBase):
    def _convert_items(self, result, img_size=(1024, 1024)):
        """convert the result (single image) in pkl file to specific format (Mask OBB, bbox + maskobb) 

        Args:
            result (tuple): detection result of single image
            img_size (tuple): image size (height, width)

        Return:
            list: converted objects
        """
        objects = []

        det, seg = result
        for label in range(len(det)):
            if label > len(seg) - 1:
                continue
            bboxes = det[label]
            if isinstance(seg, tuple):
                segms = seg[0][label]
            else:
                segms = seg[label]

            for i in range(bboxes.shape[0]):
                data = dict()
                data['bbox'] = aitool.xyxy2xywh(bboxes[i][:4])
                data['score'] = float(bboxes[i][4])
                if data['score'] < self.score_threshold:
                    continue
                data['category_id'] = self.cat_ids[label]
                if isinstance(segms[i]['counts'], bytes):
                    segms[i]['counts'] = segms[i]['counts'].decode()
                data['segmentation'] = segms[i]
                thetaobb, pointobb = aitool.segm2rbbox(segms[i])
                data['pointobb'] = pointobb
                data['thetaobb'] = thetaobb
                if thetaobb[2] * thetaobb[3] < self.min_area:
                    continue
                if not self.keep_boundary:
                    cx_flag = thetaobb[0] < 0 or thetaobb[0] > img_size[1] - 1
                    cy_flag = thetaobb[1] < 0 or thetaobb[1] > img_size[0] - 1
                    if cx_flag or cy_flag:
                        continue
                objects.append(data)

        return objects


class COCOParser():
    def __init__(self, 
                 ann_file, 
                 classes=[''],
                 data_keys=['pointobb', 'bbox', 'category_id', 'segmentation']):
        """parse coco annotation file

        Args:
            ann_file (str): coco annotation file
            classes (list, optional): class ids. Defaults to [''].
            data_keys (list, optional): parse which items. Defaults to ['bbox', 'category_id', 'segmentation'].
        """
        self.data_keys = data_keys
        self.coco = COCO(ann_file)
        self.img_ids = self.coco.get_img_ids()
        self.cat_ids = self.coco.get_cat_ids()
        self.categories = self.coco.dataset['categories']
        self.img_fns = []

        print("begin to parse the coco annotation file")
        self.objects, self.objects_with_id, self.img_name_with_id = dict(), dict(), dict()
        for img_id in tqdm.tqdm(self.img_ids):
            img_info = self.coco.load_imgs([img_id])[0]
            img_name = aitool.get_basename(img_info['file_name'])
            self.img_fns.append(img_name)

            ann_ids = self.coco.get_ann_ids(img_ids=[img_id])
            ann_info = self.coco.load_anns(ann_ids)
            self.objects[img_name] = self._convert_items(ann_info, img_info)
            self.objects_with_id[img_id] = self.objects[img_name].copy()
            self.img_name_with_id[img_name] = img_id
    
    def _convert_items(self, ann_info, img_info):
        objects = []

        img_height, img_width = img_info['height'], img_info['width']
        for ann in ann_info:
            data = dict()
            for data_key in self.data_keys:
                if data_key in ann:
                    data[data_key] = ann[data_key]
                else:
                    raise RuntimeError(f'coco ann file does not contain {data_key}')

            data['img_height'], data['img_width'] = img_height, img_width
            
            objects.append(data)

        return objects

    def __call__(self, image_fn):
        if image_fn in self.objects.keys():
            return self.objects[image_fn]
        else:
            print("{} is not in coco file".format(image_fn))
            return []

class COCOParserTinyPerson(COCOParser):
    def __init__(self, 
                 ann_file, 
                 classes=[''],
                 data_keys=['bbox', 'category_id', 'segmentation']):
        """parse coco annotation file of tinyperson dataset

        Args:
            ann_file (str): coco annotation file
            classes (list, optional): class ids. Defaults to [''].
            data_keys (list, optional): parse which items. Defaults to ['bbox', 'category_id', 'segmentation'].
        """
        self.data_keys = data_keys
        self.coco = COCO(ann_file)
        self.img_ids = self.coco.get_img_ids()
        self.cat_ids = self.coco.get_cat_ids()
        self.categories = self.coco.dataset['categories']
        self.img_fns = []

        print("begin to parse the coco annotation file")
        self.objects = dict()
        self.objects_with_id = dict()
        self.img_name_with_id = dict()
        for img_id in tqdm.tqdm(self.img_ids):
            img_info = self.coco.load_imgs([img_id])[0]
            if 'corner' in img_info:
                img_corner = [str(int(_)) for _ in img_info['corner']]
                img_name = aitool.get_basename(img_info['file_name']) + '__' + "_".join(img_corner)
            else:
                img_name = aitool.get_basename(img_info['file_name'])

            self.img_fns.append(img_name)

            ann_ids = self.coco.get_ann_ids(img_ids=[img_id])
            ann_info = self.coco.load_anns(ann_ids)
            self.objects[img_name] = self._convert_items(ann_info, img_info)
            self.objects_with_id[img_id] = self.objects[img_name].copy()
            self.img_name_with_id[img_name] = img_id
    
    def _convert_items(self, ann_info, img_info):
        objects = []

        img_height, img_width = img_info['height'], img_info['width']
        if 'corner' in img_info:
            img_corner = img_info['corner']
        else:
            img_corner = None
        for ann in ann_info:
            data = dict()
            for data_key in self.data_keys:
                if data_key in ann:
                    data[data_key] = ann[data_key]
                else:
                    raise RuntimeError(f'coco ann file does not contain {data_key}')

            data['img_height'], data['img_width'] = img_height, img_width
            if img_corner is not None:
                data['img_corner'] = img_corner
            
            objects.append(data)

        return objects

def xml_parser_plane(label_file):
    objects = []
    tree = ET.parse(label_file)
    root = tree.getroot()
    objects_handle = root.find('objects')
    if objects_handle is None:
        return []
    for single_object in objects_handle.findall('object'):
        points = single_object.find('points')
        data = {}

        pointobb = []
        for point in points[:-1]:
            coords = [float(coord) for coord in point.text.split(',')]
            pointobb += coords

        bbox = aitool.pointobb2bbox(pointobb)
        bbox = aitool.xyxy2xywh(bbox)

        data['area'] = bbox[2] * bbox[3]
        data['segmentation'] = [pointobb]
        data['pointobb'] = pointobb
        data['thetaobb'] = aitool.pointobb2thetaobb(pointobb)
        data['bbox'] = bbox
        data['category_id'] = single_object.find('possibleresult').find('name').text
        data['class'] = single_object.find('possibleresult').find('name').text
        try:
            data['score'] = single_object.find('possibleresult').find('probability').text
        except:
            print("There is not probability key")
        
        objects.append(data)

    return objects

def xml_parser_rovoc(label_file):
    objects = []
    tree = ET.parse(label_file)
    root = tree.getroot()

    for single_object in root.findall('object'):
        robndbox = single_object.find('robndbox')
        data = {}

        cx = float(robndbox.find('cx').text)
        cy = float(robndbox.find('cy').text)
        w = float(robndbox.find('w').text)
        h = float(robndbox.find('h').text)
        theta = float(robndbox.find('angle').text)

        thetaobb = [cx, cy, w, h, theta]

        pointobb = aitool.thetaobb2pointobb(thetaobb)
        bbox = aitool.thetaobb2bbox(thetaobb)
        bbox = aitool.xyxy2xywh(bbox)

        data['area'] = bbox[2] * bbox[3]
        data['segmentation'] = [pointobb]
        data['pointobb'] = pointobb
        data['thetaobb'] = thetaobb
        data['bbox'] = bbox
        data['category_id'] = 1
        
        objects.append(data)

    return objects


class COCOJsonResultParser():
    def __init__(self, 
                 res_file):
        """parse detection results of coco format

        Args:
            res_file (str): detection result file of coco format.
        """
        self.res_file = res_file
        self.results = mmcv.load(res_file)

        print("begin to parse the detection result json file")
        self.objects = defaultdict(list)
        for single_det in tqdm.tqdm(self.results):
            image_id = single_det['image_id'] 

            self.objects[image_id].append(single_det)

    def __call__(self, image_id):
        if image_id in self.objects.keys():
            return self.objects[image_id]
        else:
            print("Image id {} is not in coco result file".format(image_id))
            return []

def mask_parse(mask_file,
               subclasses=(1, 3),
               clean_polygon_flag=False,
               with_opencv=True):
    """parse mask image (png image etc.)

    Args:
        mask_file (str or np.array): mask image
        subclasses (tuple, optional): parse which class. Defaults to (1, 3).

    Returns:
        list: list of objects
    """
    if isinstance(mask_file, str):
        mask_image = cv2.imread(mask_file)
    else:
        mask_image = mask_file

    if mask_image is None:
        if isinstance(mask_file, str):
            print("Can not open this mask file: {}".format(mask_file))
        else:
            print("Can not handle mask image (np.array), it is empty")
        return []

    sub_mask = aitool.generate_subclass_mask(mask_image, subclasses=subclasses)
    if with_opencv:
        polygons = aitool.generate_polygon_opencv(sub_mask)
    else:
        polygons = aitool.generate_polygon(sub_mask)

    objects = []
    for polygon in polygons:
        object_struct = dict()
        if clean_polygon_flag:
            if not polygon.is_valid:
                continue
            if polygon.geom_type not in ['Polygon', 'MultiPolygon']:
                continue
        object_struct['mask'] = aitool.polygon2mask(polygon)
        if len(object_struct['mask']) == 0:
            continue
        object_struct['polygon'] = polygon
        objects.append(object_struct)

    return objects


class JSONParserBase():
    """parse json file
    """
    def _convert_data(self):
        pass

    def __call__(self, json_file):
        data = mmcv.load(json_file)
        image_info = data['image']
        anns = data['annotations']
        
        return image_info, anns

        